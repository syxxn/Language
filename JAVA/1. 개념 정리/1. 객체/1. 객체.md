# 클래스와 인스턴스 그리고 객체

> 클래스와 인스턴스 비유
>
> 1. 클래스는 붕어빵틀, 인스턴스(객체)는 붕어빵
> 2. 클래스는 설계도, 인스턴스(객체)는 집
> 3. 클래스는 메소드 정의, 인스턴스는 메소드 호출
>
> https://whatisthenext.tistory.com/36



```java
class Calculator{
	int left, right;
	
	public void setOperands(int left, int right){
		this.left=left;
		this.right=right;
	}
	public void sum(){
		System.out.println(this.left+this.right);
	}
	public void avg(){
		System.out.println((this.left+this.right)/2);
	}
}
```

```java
public class CalculatorDemo{
	public static void main(String[] args){
		Caculator c1 = new Calculator();//우항이 실행되어 좌항에 대입
        //new 키워드를 사용하여 객체를 만듦
        //1. JVM에 생성된 Calculator 객체를 c1이 가리키고 있음
        //2. 객체를 가리키고 있는 변수의 자료형은 그 객체
        // 객체가 담겨있는 변수도 객체
		c1.setOperands(10,20);
		c1.sum();
		c1.avg();
		
		Calculator c2=new Calculator();
		c2.setOperands(20,40);
		c2.sum();
		c2.avg();
	}//두개의 객체는 변수값(상태)가 다름
}
```





### 클래스(Class)

: 함수를 담은 구조체

##### 클래스를 만든다는 것은 사용자 정의 데이터 타입을 만드는 것과 같은 의미

+ 하나의 클래스 파일 안에 여러개의 클래스 작성이 가능함.(드물게 사용됨)

  > BUT, 그 파일 이름과 동일한(리더가 되는) 클래스는 public을 붙여줘야함.

`class [클래스명]{}`

+ 클래스 안에 선언한 메소드는 그냥 사용할 수가 없음.

  > 그래서 객체를 만들어서, 객체를 이용해서 그 메소드로 접근하는 것




**객체 변수의 값이 독립적으로 유지된다!**



____



### 객체(Object)

: 프로그램 안의 작은 프로그램으로 변수와 메소드의 집합 (모든 인스턴스를 대표하는 포괄적 의미)

> 인스턴스를 성공적으로 가리킨 것

> 현실의 대상과 비슷하여 상태나 행동 등을 가지지만, 소프트웨어 관점에서는 그저 사유의 결과일 뿐

+ 객체는 **속성**과 **기능**의 집합이며, 각각을 객체의 멤버라고 함
  + 속성(property) : 멤버변수, 특성, 필드, 상태
  
  > 사람 A의 나이는 24세
  
  + 기능(function) : 메소드, 행위, 함수
  
    > 사람 A가 "달리고" 있음
  
+ SOLID 원칙 

  > SRP(단일 책임 원칙) : 하나의 객체는 하나의 책임(기능)만을 가짐



### 인스턴스(Instance)

: 메모리(JVM)에 할당된 실체

: "하나의 클래스(생성자)"로부터 만들어진 것인지를 강조하는 구체적 의미

: 클래스에서 정의된 속성과 성질을 가진 실체적인 객체로 표현된 것

> 객체가 메모리에 할당되어 실제 사용될 때

+ 실체화된 인스턴스는 메모리에 할당됨



예를 들어, 카드를 만든다고 하자. 여러 장의 카드를 만들 때 설계도(클래스)는 같아야 하지만, 카드 유효기간, 카드 번호, 고객 이름 등은 달라야 한다. 고객마다 가지고 있는 정보가 다르므로 서로 다른 상태를 갖게 하기 위해서 인스턴스를 생성하는 것이다. 

>  **기본적인 틀은 같지만 세부적인 내용은 다르게** 해서 중복을 없애기 위해 인스턴스 사용



> 객체와 인스턴스는 다르지만 비슷함. 객체는 포괄적인 느낌
>
> > 메모리에 올라가 있지 않은 것도 객체라 할 수 있음. 인스턴스는 메모리에 할당되어야만 함
>
> **인스턴스라고 하는 것이 더 정확함**
>
> -> 소프트웨어 세계에 더 가깝기 때문



____



### 객체화 또는 인스턴스화

: 객체가 들어갈 공간을 확보하고 클래스로부터 객체를 만드는 것

##### + 중복되는 것을 제거하여 유지보수를 편리하게 하고, 가독성과 재활용성을 좋게 하기 위해 사용



+ JVM에 인스턴스가 생성되면 클래스(사용자 정의 데이터 타입) 자료형의 인스턴스 변수에 인스턴스 주소값을 넣음

>  이 때 사용하는 변수의 데이터타입은 자신이 가리키고 있는 인스턴스의 자료형과 같아야함
>
> > 자기 클래스 안에서 자신을 모방한 인스턴스도 만들 수 있는데, 이것도 지금은 패스
>
> > 생성된 인스턴스를 만든 클래스의 타입과 같아야 함
> >
> > (다른 경우도 있는데 이건 상속과 관련 있으니까 지금은 패스)

+ 생성자를 선언하지 않으면 클래스(기본 생성자 이용(인자값 x))를 인스턴스화하고, 생성자를 선언했으면 그 생성자로만 인스턴스화를 할 수 있음



```java
Scanner sc = **new** Scanner(System.in);  -> 객체 생성 == 인스턴스화

//new 클래스명();-> 새로운 객체를 만듦.

//System.in-> 시스템적으로 input을 받아온다/ 키보드로 입력받음.    
```



> 메모리에 올라가 있지 않아도 **객체**라고 할 수 있고, 각각의 행동이나 속성에 대한 틀을 잡아 놓은 것을 **클래스**, 상황에 따라 다르게 적용할 수 있도록 **인스턴스**로 만듦!





##### 오류!

> 유틸리티 클래스(또는 헬퍼 클래스)는 정적 메소드만을 가지고 있고, 상태를 내포하지 않는 "구조"이다

```java
public class Main {
    public static void main(String[] args){
            Main m=new Main();
            m.main();
        }//라고 하게 되면 오류가 난다.
    }//[Instantiation of utility class 'Main']
}
```

> static에 접근하기 위해서는 인스턴스를 만들어서 접근하는 것이 아니라, 그 자체에 직접 접근해야 한다
>
> `Main.main`//(클래스).(스태틱 함수)